package adts;public class Bag_Linked<T> implements BagInterface<T> {    private Node firstNode;       // reference to first node    private int numberOfEntries;    public Bag_Linked() {        firstNode = null;        numberOfEntries = 0;    } // end default constructor    /*     * Sees whether this bag is empty.     */    @Override    public boolean isEmpty() {        return numberOfEntries == 0;    }     /*     * Gets the number of entries currently in this bag.     */    @Override    public int getSize() {        return numberOfEntries;    }    /*     * Adds a new entry to this bag.     */    @Override    public boolean add(T newEntry) {    // OutOfMemoryError possible        // add to beginning of chain:        Node newNode = new Node(newEntry);        newNode.next = firstNode;         // make new node reference rest of chain (firstNode is null if chain is empty)                firstNode = newNode;              // new node is at beginning of chain        numberOfEntries++;        return true;    }    /**     * Sees whether this bag is full.     * Note: Linked List bag is never full.     */    @Override    public boolean isFull() {        return false;    }    /*     * Removes one unspecified entry from this bag, is always the      * node pointed to by the variable firstNode.     *      */    @Override    public T remove() {        T result = null;         // declare and set reference to null        // Test to see if list is empty,         // ie firstNode != null        if (firstNode != null ) {            result = firstNode.data;             // result now point to first element on the list            //firstNode now points to the second item in the list            firstNode = firstNode.next;             numberOfEntries--;             // now we have one fewer entries on the list.        }        return result;    }    /*     * Removes one occurrence of a given entry from this bag.     * This method will need to locate the reference then delete it from     * the list.     * It will use:     *  getReferenceTo()     *  remove()     *      */    @Override    public boolean remove(T anEntry) {        // set result to false indicating we didn't find it        boolean result = false;        Node nodeN = getReferenceTo(anEntry);         // returns node reference or null        // if the value was not null it found a match        if(nodeN != null) {            nodeN.data = firstNode.data;            remove();            result = true;        }        return result;    }     /*     * This private function added here to allow us to locate the reference     * to a particular item in the list if it exists     */        public Node getReferenceTo(T anEntry){        boolean found = false;        /*         * Now we set the beginning reference to the first node in the list.         * From this point we can traverse the list with a while loop untiil         * we either locate the value or return null.         * This function can serve dual purposes in our implementation of          * linked list.         */        Node currentNode = firstNode;         // while loop to traverse the list        while(!found && (currentNode != null)){            if(anEntry.equals(currentNode.data))                found = true;            else {                currentNode = currentNode.next;            }        }        return currentNode;            }                /*     * Removes all entries from this bag.     *      * Java knowlegde:     *    1. set numberOfEntries = 0     *    2. set firstNode = null     */    @Override    public void clear() {        numberOfEntries = 0;        firstNode = null;    }    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry the entry to be counted     * @return the number of times anEntry appears in the bag     */    @Override    public int getFrequencyOf(T anEntry) {        int frequency = 0;        int counter = 0;        Node currentNode = firstNode;        while ((counter < numberOfEntries) && (currentNode != null)) {            if (anEntry.equals(currentNode.data)) {                frequency++;            }            counter++;            currentNode = currentNode.next;        }        return frequency;    }    /*     * Tests whether this bag contains a given entry.     */    @Override    public boolean contains(T anEntry) {        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (anEntry.equals(currentNode.data)) {                found = true;            } else {                currentNode = currentNode.next;            }        }         return found;    }    /*     * Retrieves all entries that are in this bag.     */    @Override    public T[] toArray() {        // the cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] result = (T[]) new Object[numberOfEntries]; // unchecked cast        int index = 0;        Node currentNode = firstNode;        while ((index < numberOfEntries) && (currentNode != null)) {            result[index] = currentNode.data;            index++;            currentNode = currentNode.next;        } // end while        return result;    } // end toArray        /** Private inner class node.     *      * Important Note: Data members of an inner class are visible to the     * methods of the enclosing class, this leads to simpler implementations     * of dynamically allocated storage.     */    private class Node {        private T data; // entry in bag        private Node next; // link to next node        private Node(T dataPortion) {            this(dataPortion, null);        } // end constructor        private Node(T dataPortion, Node nextNode) {            data = dataPortion;            next = nextNode;        }    }}