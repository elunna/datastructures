package adts;public class Bag_Linked<T> implements BagInterface<T> {    private Node firstNode;         // reference to first node    private int numberOfEntries;        public Bag_Linked() {        this.firstNode = null;        this.numberOfEntries = 0;    }    // *************************************************************************    // *** STATIC METHODS ******************************************************    /*     * Gets the number of entries currently in this bag.     */    @Override    public int size() {        return numberOfEntries;    }    /*     * Sees whether this bag is empty.     */    @Override    public boolean isEmpty() {        // return numberOfEntries == 0;        return firstNode == null;    }    /**     * Sees whether this bag is full.     *     * @return Linked chain is never full, always returns false.     */    @Override    public boolean isFull() {        return false;    }    /*     * Tests whether this bag contains a given entry.     */    @Override    public boolean contains(T anEntry) {        if (anEntry == null) {            return false;        }        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (anEntry.equals(currentNode.getData())) {                found = true;            } else {                currentNode = currentNode.getNext();            }        }        return found;    }    /*     * Retrieves all entries that are in this bag.     */    @Override    public T[] toArray() {        // the cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] result = (T[]) new Object[numberOfEntries]; // unchecked cast        int index = numberOfEntries - 1;        Node currentNode = firstNode;        while ((index < numberOfEntries) && (currentNode != null)) {            result[index] = (T) currentNode.getData();            index--;            currentNode = currentNode.getNext();        }        return result;    }    /**     * Locate the reference to a particular item. Set the beginning ref to the     * first node, then traverse with a while loop until we find the value or     * return null.     */    private Node getReferenceTo(T entry) {        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (entry.equals(currentNode.getData())) {                found = true;            } else {                currentNode = currentNode.getNext();            }        }        return currentNode;    }    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry the entry to be counted     * @return the number of times anEntry appears in the bag     */    @Override    public int getFrequencyOf(T anEntry) {        int frequency = 0;        int counter = 0;        Node currentNode = firstNode;        while ((counter < numberOfEntries) && (currentNode != null)) {            if (anEntry.equals(currentNode.getData())) {                frequency++;            }            counter++;            currentNode = currentNode.getNext();        }        return frequency;    }    private Node getNodeAt(int index) {//        assert (firstNode != null)//                && (1 <= givenPosition) && (givenPosition <= numberOfEntries);        Node currentNode = firstNode;        // traverse the chain to locate the desired node        for (int counter = 1; counter < index; counter++) {            currentNode = currentNode.getNext();        }        // assert currentNode != null;        return currentNode;    }    // *************************************************************************    // *** MUTATOR METHODS *****************************************************    /*     * Adds a new entry to the beginning of chain:     * OutOfMemoryError possible     */    @Override    public boolean add(T newEntry) {        if (newEntry == null) {            return false;        } else {            Node newNode = new Node(newEntry);            newNode.setNext(firstNode);            firstNode = newNode;            numberOfEntries++;            return true;        }    }    /*     * Removes one unspecified entry     * It is always the node pointed to by the variable firstNode.     */    @Override    public T remove() {        return remove(0);    }    @Override    public T remove(int index) {        if (isEmpty() || index < 0 || index > numberOfEntries - 1) {            return null;        }        T result;        if (index == 0) {            result = (T) firstNode.getData();            firstNode = firstNode.getNext();        } else {            Node nodeBefore = getNodeAt(index);            Node nodeToRemove = nodeBefore.getNext();            Node nodeAfter = nodeToRemove.getNext();            nodeBefore.setNext(nodeAfter);            result = (T) nodeToRemove.getData();        }        numberOfEntries--;        return result;    }        /**     * Remove one occurrence of an entry. Needs to locate the reference then     * delete. Uses getReferenceTo(), remove()     *     * @param entry     * @return     */    @Override    public boolean remove(T entry) {        if (entry == null) {            return false;        }        Node removeThis = getReferenceTo(entry);        if (removeThis != null) {            removeThis.setData(firstNode.getData());            remove();            return true;        } else {            return false;        }    }        /*     * Removes all entries from this bag.     */    @Override    public void clear() {        numberOfEntries = 0;        firstNode = null;    }}