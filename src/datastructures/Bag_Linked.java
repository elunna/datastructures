package datastructures;import java.util.Arrays;import java.util.Objects;/** * A Bag ADT that uses a chain of linked nodes. * * @author Erik Lunna * @param <T> */public class Bag_Linked<T> implements BagInterface<T> {    private Node firstNode;    private int numberOfNodes;    public Bag_Linked() {        firstNode = null;        this.numberOfNodes = 0;    }    @Override    public boolean add(T newEntry) {        if (newEntry == null) {            return false;        } else {            Node newNode = new Node(newEntry);            newNode.setNext(firstNode);            firstNode = newNode;            numberOfNodes++;            return true;        }    }    @Override    public int size() {        return numberOfNodes;    }    @Override    public boolean isEmpty() {        boolean result;        if (numberOfNodes == 0) {            assert firstNode == null;            result = true;        } else {            // extra precaution?            assert firstNode != null : "numberOfEntries is not 0 but firstNode is null";            result = false;        }        return result;    }    @Override    public boolean isFull() {        return false;    }    @Override    public boolean contains(T anEntry) {        if (anEntry == null) {            return false;        }        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (anEntry.equals(currentNode.getData())) {                found = true;            } else {                currentNode = currentNode.getNext();            }        }        return found;    }    @Override    public T[] toArray() {        // the cast is safe because the new array contains null entries        @SuppressWarnings(value = "unchecked")        T[] result = (T[]) new Object[numberOfNodes]; // unchecked cast        int index = numberOfNodes - 1;        Node currentNode = firstNode;        while ((index < numberOfNodes) && (currentNode != null)) {            result[index] = (T) currentNode.getData();            index--;            currentNode = currentNode.getNext();        }        return result;    }    @Override    public int count(T anEntry) {        int frequency = 0;        int counter = 0;        Node currentNode = firstNode;        while ((counter < numberOfNodes) && (currentNode != null)) {            if (anEntry.equals(currentNode.getData())) {                frequency++;            }            counter++;            currentNode = currentNode.getNext();        }        return frequency;    }    @Override    public T remove(T entry) {        T result = null;        if (entry == null) {            throw new IllegalArgumentException();        } else if (size() == 0) {            throw new IllegalStateException();        }        Node removeThis = getReferenceTo(entry);        if (removeThis != null) {            result = (T) removeThis.getData();            removeThis.setData(firstNode.getData());            remove();            return result;        } else {            return result;        }    }    @Override    public T remove() {        if (size() == 0) {            throw new IllegalStateException();        }        T result = null;        if (firstNode != null && !isEmpty()) {            result = (T) firstNode.getData();            firstNode = firstNode.getNext(); // remove first node from chain            numberOfNodes--;        }        return result;    }    @Override    public void clear() {        numberOfNodes = 0;        firstNode = null;    }    @Override    public boolean equals(Object aThat) {        if (this == aThat) {            return true;        }        if (!(aThat instanceof Bag_Linked)) {            return false;        }        Bag_Linked that = (Bag_Linked) aThat;        return Arrays.equals(this.toArray(), that.toArray()); //array!    }    @Override    public int hashCode() {        int hash = 5;        hash = 37 * hash + Objects.hashCode(this.firstNode);        hash = 37 * hash + this.numberOfNodes;        return hash;    }    /**     * Locate the reference to a particular item. Set the beginning ref to the     * first node, then traverse with a while loop until we find the value or     * return null.     *     * @param entry     * @return Node referencing the entry object.     */    private Node getReferenceTo(T entry) {        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (entry.equals(currentNode.getData())) {                found = true;            } else {                currentNode = currentNode.getNext();            }        }        return currentNode;    }}//    @Override//    public void display() {//        displayChain(firstNode);//    }////    private void displayChain(Node nodeOne) {//        if (nodeOne != null) {//            System.out.println(nodeOne.getData()); // display first node//            displayChain(nodeOne.getNext());//        }//    }